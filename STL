vector<int,int> = {10,20,30,40,50,60,70,80,90}
v.emplace_back(1,2); 
v.push_back({1,2});
v.back() //90

for(auto it:v){
cout<<it;
}
v.erase(v.begin()+1,v.begin()+4)    {10,50,60,70,80,90}
vector<int> v(2, 100); {100,100} 

v.insert(pos,element)
v.insert(v.begin(),300); {300,100,100}
v.insert(v.begin()+1,2,10); {300,10,10,100,100}
vector<int> copy(44,55);
v.insert(v.begin(),copy.begin(),copy.end()); {44,55,300,10,10,100,100} 

v.pop_back();
v.swap(w);
v.clear();
v.empty() --> true or false output


list<int> ls; ls.push_back(2); ls.emplace_back(4);
ls.push_front(5); //vector insert is costlier than list push_front
ls.emplace_front();{2,4};
deque<int> dq; pb,eb,pf,ef,popb,popf,back(), front() 

stack--> LIFO O(1)
stack<int> st;
st.emplace(5) or st.push(5)
st.push(4)
st.push(3)
st.push(2)
st.push(1)
st.top()  //1 , {1,2,3,4,5}
st.pop() {2,3,4,5}
st.size() //4
st.empty()
stack <int> s1,s2; s1.swap(s2);

queue--> FIFO O(1)
queue<int> q; 
q.push(10)
q.push(20)
q.push(30) 
q.back()+=10;
cout<<q.back() //40
cout<<q.front() //10
q.pop() //{20,40};

push/pop==> O(logn)
top==> O(1)
priority_queue<int> pq; //not linear
pq.push(5);pq.push(2);pq.push(3);pq.push(10);pq.emplace(8); 
pq.top() ///10
pq.pop(); pq.top(); //8 

MIN HEAP
priority_queue<int,vector<int>, greater<int>> pq; 
pq.push(5);pq.push(2);pq.push(3);pq.push(10);pq.emplace(8); 
pq.top() //2

set: stores evrything in sorted order and all elements are unique 
every operation ==> O(logn)
set<int> st;
st.insert(1);st.insert(2);st.insert(2);st.emplace(34);st.insert(44); 
{44,34,6,5,4,3,2,1}
auto it= st.find(3) //if no 3 found it'll return st.end() 
st.erase(2) {44,34,6,5,4,3,1}
auto it1=st.find(44), auto it1=st.find(6)
st.erase(it1,it2) //{6,5,4,3,1} first,last+1 or just give element
int cnt=st.count(1); if 1 exists=1 else it doesn't exist cnt=0;

auto it=st.lower_bound(2); auto it= st.upperbound(3); 

multiset: stores evrything in sorted order, duplicates can be present 
multiset<int> ms; 
ms.insert(1);ms.insert(1);ms.insert(1); {1,1,1}
int cnt=ms.count(1) //3
ms.erase(1); {}
ms.erase(ms.find(1)); //only single one is erased {1,1}
ms.erase(ms.find(1), ,ms.find(1) +2) ; 

unodered_set<int> us;
