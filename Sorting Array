1. Selection Sort
bring min to the front and swaps with last number

for(int i=0;i<n-1;i++){
 int mini=i;
 for(int j=i;j<n-1;j++){
  if(arr[j] <arr[mini] mini=j;
 }
 swap(arr[i], arr[mini]);
} Time complexity: O(N2)

2. Bubble Sort
Pushes max to the last 
void bubble(int arr[], int n){
 bool swaphuakya=false;
    for(int i=n-1;i>0;i--){
        for(int j=0;j<i;j++){
          if(arr[j]>arr[j+1]){
              swap(arr[j],arr[j+1]);swaphuakya=true;
          }
        }
          if(swaphuakya==false){break;}
    }
} Time complexity: O(N2) [worst and average] O(N) Best case

3. Insertion Sort 
void insertion(int arr[],int n){
    for(int i=0;i<n-1;i++){
     for(int j=i+1;j>=1;j--){
      if(arr[j]<arr[j-1]) swap(arr[j],arr[j-1]);
     }  
   }  
}  Time complexity: Time complexity: O(N2) [worst and average] O(N) Best case

4. Merge Sort Time complexity: O(NlogN) base 2
input-->mergesort(arr, 0, n-1);
void merge(vector<int> &arr, int low,int mid,int high){
    vector<int> temp;
    int l=low;
    int r=mid+1;
    while(l<=mid && r<=high){
        if(arr[l]<=arr[r]){
            temp.push_back(arr[l]); l++;
        }
        else{
            temp.push_back(arr[r]); r++;
        }
    }
    while(l<=mid){ //while loops not if
        temp.push_back(arr[l]); l++;
    }
    while(r<=high){
        temp.push_back(arr[r]); r++;
    }
    for(int i=low;i<=high;i++){ //i=0  no i<high 
        arr[i]=temp[i-low];
    }
}
void mergesort(vector<int>& arr, int l, int h){
    if (l>=h) return;
    int mid=(l+h)/2;
    mergesort(arr,l, mid);
    mergesort(arr,mid+1, h);
    merge(arr,l,mid, h);
} 
5. Recursive Bubble Sort 
void bubblerecursive(vector<int> &arr, int n){
    if(n==1) return;
    for(int j=0;j<=n-2;j++){
        if(arr[j]>arr[j+1]){
              swap(arr[j],arr[j+1]); 
        }
    }
    bubblerecursive(arr,n-1);
}Time complexity: O(N2) [worst and average] O(N) Best case

6. Recursive Insertion
input--> recursiveinsertion(arr,n,1);
void recursiveinsertion(vector<int> &arr,int n, int i){
    if(i==n) return;
    
     for(int j=i;j>=0;j--){ //j goes till n-1
      if(arr[j]<arr[j-1]) swap(arr[j],arr[j-1]); 
     }  
    recursiveinsertion(arr,n,i+1);
}  Time complexity: O(N) best case

7.Quick Sort
int f(vector<int> &arr,int low,int high){
    int pivot=arr[low];
    int i=low;int j=high;
    while(i<j){
        while(arr[i]<=pivot && i<=high-1) i++;
        while(arr[j]>pivot && j>=low+1) j--;
        if(i<j) swap(arr[i],arr[j]);
    }
    swap(arr[low], arr[j]);
    return j;
}
void quick(vector<int> &arr,int low,int high){
    if(low>high) return;
    if(low<high){
       int part=f(arr,low,high);
       quick(arr,low,part-1); 
       quick(arr,part+1,high);
    }
} Time Complexity for the best and average case: O(N*logN),Worst Case Time complexity: O(n2) 

